# -*- coding: utf-8 -*-
"""python oops assignment

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uHbxdBxX8AiG-HnMd6xgVz7OWpcF77ZQ

theory qustions

Q-1 What is Object-Oriented Programming (OOP) ?

  -- Object-Oriented Programming (OOP) is a programming paradigm that organizes software design around objects rather than functions and logic. An object is a self-contained unit that bundles data (attributes or properties) and the behaviors that act on that data (methods).

This approach mirrors how we perceive the real world, where objects like a "car" have attributes (color, brand, speed) and can perform actions (accelerate, brake, turn). In OOP, a Car object would contain variables for its color and brand and methods like accelerate() and brake().

Q-2  What is a class in OOP?

  --oriented programming (OOP), a class is a blueprint or a template for creating objects. It's not an actual object itself, but rather a logical structure that defines the common attributes (data) and methods (behaviors) that all objects of that class will possess.

  class-The blueprint. It's a definition that outlines the structure and behavior. For example, a Car class would define that all cars have attributes like color and speed, and methods like accelerate() and brake(). No memory is allocated for a class itself.

Q-3 What is an object in OOP?

  --In OOP, an object is a specific instance of a class. It's a fundamental, self-contained unit that combines data (its state or properties) and the methods (its behavior) that operate on that data. While a class is a blueprint, an object is the tangible, real-world entity created from that blueprint.

Q-4  What is the difference between abstraction and encapsulation?
  
  --Abstraction:- Abstraction is the process of hiding complex implementation details and showing only the essential features of an object. It provides a simplified, high-level view of a system. Think of a TV remote control. You use the buttons to change channels, adjust the volume, and power the TV on or off. You don't need to know about the intricate electronic circuits inside the remote or how it communicates with the TV. The remote is an abstraction—it presents a simple interface that hides all the underlying complexity.In programming, abstraction is achieved using abstract classes and interfaces. They define a blueprint of methods that must be implemented by concrete classes, but they don't provide the actual implementation. This allows you to design a system based on what objects should do, without getting bogged down in how they will do it.


Encapsulation:- Encapsulation is the practice of bundling data (variables) and the methods (functions) that operate on that data into a single unit, typically a class. It's a protective wrapper that prevents direct access to the data from outside the class. Instead, data can only be accessed or modified through the class's public methods, often called "getters" and "setters".The main goal of encapsulation is data hiding. By making the data private, you ensure its integrity and prevent it from being accidentally or maliciously changed by external code. For example, a Car class might have a private speed variable. You wouldn't want other parts of the program to directly change the speed to a negative number or an absurdly high value. Instead, you'd provide a setSpeed() method that includes validation logic to ensure the new speed is within a valid range. This secures the data and makes the code more robust.

Q-5 What are dunder methods in Python?

  -- Dunder methods in Python are special methods with names that start and end with two underscores, like __init__ or __str__. The "dunder" is a shorthand for "double underscore."

  example== * __init__(self,....)
            * __str__(self):

Q-6  Explain the concept of inheritance in Oop?

  --Inheritance is a fundamental concept in object-oriented programming (OOP) that allows a new class to reuse, extend, and modify the properties and behaviors of an existing class. It's a way of modeling a hierarchical "is-a" relationship between classes.

The class that is inherited from is called the superclass, parent class, or base class. The new class that inherits is called the subclass, child class, or derived class.

Q-7 What is polymorphism in OOP?

  --Polymorphism, one of the four pillars of OOP, means "many forms." It allows a single interface, function, or operator to behave differently based on the data type or class it's acting upon. This makes your code more flexible, reusable, and readable.



A simple example is the built-in len() function in Python. It can find the length of a string, a list, or a dictionary, even though these are different data types.  The function itself doesn't change; its behavior adapts to the object it's given.

Q-8  How is encapsulation achieved in Python?

   --Encapsulation is achieved in Python by using name mangling to make attributes "private," which is a convention for restricting direct access to an object's data. Unlike some other languages, Python doesn't have a strict concept of private or protected members. Instead, it relies on a set of conventions and a name-mangling feature to enforce encapsulation.

Q-9 What is a constructor in Python?

  --A constructor in Python is a special method used to initialize an object's state when it is created. It is automatically called when you instantiate a class, and its primary purpose is to set up the new object by assigning initial values to its attributes.

  method:- __init__

Q-10 What are class and static methods in Python?

  --Class and static methods in Python are both types of methods that are defined within a class but behave differently from instance methods. While an instance method requires an object of the class to be called and receives self (the instance) as its first argument, class and static methods don't need an instance.

  Class Method:-A class method is bound to the class itself, not to an instance of the class. It receives the class as its first argument, conventionally named cls, instead of self. Class methods are defined using the @classmethod decorator.

  static method:-A static method is not bound to either the class or its instance. It's just a regular function that happens to be inside a class's namespace. It doesn't receive self or cls as its first argument. Static methods are defined using the @staticmethod decorator.

Q-11  What is method overloading in Python?

  --ethod overloading is the ability to define multiple methods within the same class with the same name but different signatures, typically by having a different number or type of parameters. Python does not support method overloading in the same way as languages like Java or C++.
  
  When you define multiple methods with the same name in a Python class, the last one defined will overwrite all the previous ones. Python's dynamic typing means it doesn't need to know the data type of the arguments at compile time. It simply looks for a method with a specific name, and if it finds one, it calls it.

Q-12 What is method overriding in OOP?

  --Method overriding is an OOP concept where a subclass provides its own specific implementation for a method that is already defined in its parent class. This allows a child class to change the behavior it inherits from its parent, providing a different functionality while keeping the same method name and signature.

Q-13  What is a property decorator in Python?

  --A property decorator in Python is a way to create properties within a class. It allows you to define methods that can be accessed like attributes, providing a cleaner, more "Pythonic" interface for getting, setting, or deleting an attribute's value. This is a key tool for achieving encapsulation in Python.

Q-14  Why is polymorphism important in OOP?

  --Polymorphism is crucial in OOP because it promotes flexibility, reusability, and maintainability in code. It allows you to write more generic and robust code that can work with objects of different classes that share a common interface.

  Reason for importans:

 * Code Reusability: Polymorphism allows you to write functions and methods that can operate on a range of different objects, rather than having to write separate code for each object type. For example, you can create a draw_shape() function that works for a Circle, a Square, and a Triangle, as long as all these objects have a draw() method. This avoids code duplication and makes your system more efficient.

 * Flexibility and Extensibility:With polymorphism, you can easily extend your system without having to modify existing code. If you add a new class (like Star) that inherits from the same parent and implements the draw() method, your draw_shape() function will automatically work with the new Star object without any changes. This makes your codebase more adaptable to new features and changes.

Q-15  What is an abstract class in Python?

  --An abstract class is a blueprint for other classes, containing one or more abstract methods. You can't create an instance of an abstract class; you must inherit from it to create a concrete class. Abstract methods are declared but don't have an implementation, forcing subclasses to provide their own.

Q-16  What are the advantages of OOP?

  --The primary advantages of object-oriented programming (OOP) are code reusability, modularity, and scalability. It models real-world entities as objects, making it a natural way to design software.

  Advantages:
    
    * Code Reusability:  OOP allows you to create classes that can be reused in different parts of a program or in new projects. Through inheritance, a new class can inherit and extend the properties and behaviors of an existing one, which saves time and effort.

    * Modularity: Objects are self-contained, independent units with their own data and behavior. This makes a program's structure more organized and easier to understand. If you need to fix a bug or change a feature, you can often do so within a single object without affecting the rest of the code. This is a core benefit of encapsulation.

    *  Flexibility and Extensibility: Polymorphism allows you to design systems that are flexible and easy to extend. New features or objects can be added without having to change existing code, as long as they adhere to the common interface. This makes a system more adaptable to change and growth.

Q-17 What is the difference between a class variable and an instance variable?

  -- Class Variables:- A class variable is declared inside the class but outside of any method. Because it's shared, all objects of that class have access to the same value. Changes made to a class variable by one instance will be reflected in all other instances. They're typically used for data that is constant across all objects of a class, such as a counter for the number of objects created or a default value.

  Instance Variables: An instance variable is defined inside a method, usually the __init__ constructor, using the self keyword. Each instance has its own copy of the variable, so changes made to it in one instance do not affect other instances. They are used to store data that is unique to each object.

Q-18 What is multiple inheritance in Python?

  -- Multiple inheritance is an object-oriented programming feature that allows a class to inherit from more than one parent class. This enables the child class to combine the attributes and methods of all its parent classes, creating a single, cohesive unit from multiple sources.

Q-19  Explain the purpose of ‘’__str__’ and ‘__repr__’ ‘ methods in Python.

  --__str__
         The __str__ method returns a human-readable string representation of an object. It's meant to be used for end-users or for display purposes, such as with the print() function or the str() built-in. The goal is to produce a readable, concise output that summarizes the object's state in a friendly way. If __str__ is not defined, Python falls back to __repr__.


    __repr__
  
  The __repr__ method returns an unambiguous, developer-oriented string representation. It's primarily used for debugging and logging. The goal is to return a string that, if passed to eval(), would create the same object. Think of it as a detailed, technical representation of the object's state.

Q-20 is the significance of the ‘super()’ function in Python?

  --The super() function in Python is a built-in function that provides a way to call a method from the parent (superclass) in a class hierarchy. Its primary purpose is to ensure that a child class, when overriding a method, can still leverage the functionality of the parent's version of that same method, rather than having to rewrite all the inherited logic.

Q-21 What is the significance of the __del__ method in Python?

  --he __del__ method, also known as the destructor, is a special method in Python that is called when an object is about to be "destroyed" or garbage-collected. Its primary purpose is to perform cleanup actions

  How it works: Unlike a constructor, which is called when an object is created, the __del__ method is invoked when the reference count of an object drops to zero, meaning there are no more variables or data structures pointing to it. The garbage collector then reclaims the memory used by that object.

Q-22 What is the difference between @staticmethod and @classmethod in Python?

  -- Difference between @staticmethod and @class method:

  @staticmethod:- A static method is essentially a regular function that is logically grouped with a class. It can't access or modify the class state or the instance state. It's often used for utility functions that are related to the class but don't depend on any of the class's or instance's data.

  @classmethod:- A class method is bound to the class and can access and modify class-level attributes, which are shared by all instances. It's defined with @classmethod and receives the class itself, conventionally named cls, as its first argument.

Q-23  How does polymorphism work in Python with inheritance?

  --Polymorphism works with inheritance in Python by allowing methods in a subclass to override methods in a parent class. This enables objects of different classes that share a common superclass to be treated interchangeably, responding in their own unique way to the same method call.

  Example in Python:

  class Animal:
    def speak(self):
        raise NotImplementedError("Subclass must implement abstract method")

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"


animals = [Dog(), Cat()]


for animal in animals:
    print(animal.speak()) # The correct speak() method is called for each object.

Q-24  What is method chaining in Python OOP?

  --Method chaining is a programming technique that allows you to call multiple methods on an object in a single, sequential line of code. This is possible when each method returns a reference to the same object on which the next method is called, allowing the calls to be "chained" together.

Q-25  What is the purpose of the __call__ method in Python?

  -- The __call__ method in Python lets you make an object callable, just like a function. If a class has a __call__ method, you can call an instance of that class using parentheses ().

Practical qustions

Q-1 Create a parent class Animal with a method speak() that prints a generic message. Create a child class Dog
that overrides the speak() method to print "Bark!".
"""

# The parent class, Animal, with a generic speak method.
class Animal:
    """
    A generic animal class with a method for speaking.
    """
    def speak(self):
        """
        Prints a generic message about the animal speaking.
        """
        print("The animal makes a sound.")

# The child class, Dog, which inherits from Animal.
# It overrides the speak method to provide a more specific message.
class Dog(Animal):
    """
    A specific dog class that inherits from Animal and overrides the speak method.
    """
    def speak(self):
        """
        Prints a specific message for a dog's sound.
        """
        print("Bark!")

# Create an instance of the Animal class
generic_animal = Animal()
# Call the speak method on the Animal instance
print("Calling speak() on the generic Animal:")
generic_animal.speak()

print("-" * 20)

# Create an instance of the Dog class
my_dog = Dog()
# Call the speak method on the Dog instance.
# This will call the overridden method from the Dog class.
print("Calling speak() on the Dog:")
my_dog.speak()

"""Q-2  Write a program to create an abstract class Shape with a method area(). Derive classes Circle and Rectangle
from it and implement the area() method in both
"""

from abc import ABC, abstractmethod
import math

# Abstract base class
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

# Derived class: Circle
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius ** 2

# Derived class: Rectangle
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

# Testing the classes
if __name__ == "__main__":
    c = Circle(5)
    r = Rectangle(4, 6)

    print(f"Area of Circle: {c.area():.2f}")
    print(f"Area of Rectangle: {r.area():.2f}")

"""Q-3 Implement a multi-level inheritance scenario where a class Vehicle has an attribute type. Derive a class Car
and further derive a class ElectricCar that adds a battery attribute.
"""

# Base class
class Vehicle:
    def __init__(self, vehicle_type):
        self.type = vehicle_type

    def display_info(self):
        print(f"Vehicle Type: {self.type}")

# First-level derived class
class Car(Vehicle):
    def __init__(self, vehicle_type, brand):
        super().__init__(vehicle_type)
        self.brand = brand

    def display_info(self):
        super().display_info()
        print(f"Car Brand: {self.brand}")

# Second-level derived class
class ElectricCar(Car):
    def __init__(self, vehicle_type, brand, battery_capacity):
        super().__init__(vehicle_type, brand)
        self.battery = battery_capacity

    def display_info(self):
        super().display_info()
        print(f"Battery Capacity: {self.battery} kWh")

# Testing the classes
if __name__ == "__main__":
    e_car = ElectricCar("Four-wheeler", "Tesla", 75)
    e_car.display_info()

"""Q-4 Demonstrate polymorphism by creating a base class Bird with a method fly(). Create two derived classes
Sparrow and Penguin that override the fly() method.
"""

# Base class
class Bird:
    def fly(self):
        print("Some bird is flying...")

# Derived class 1
class Sparrow(Bird):
    def fly(self):
        print("Sparrow flies high in the sky!")

# Derived class 2
class Penguin(Bird):
    def fly(self):
        print("Penguins cannot fly, but they swim well!")

# Function to demonstrate polymorphism
def bird_flight(bird_obj):
    bird_obj.fly()  # This will call the appropriate fly() method

# Testing the classes
if __name__ == "__main__":
    bird1 = Sparrow()
    bird2 = Penguin()

    bird_flight(bird1)  # Outputs: Sparrow flies high in the sky!
    bird_flight(bird2)  # Outputs: Penguins cannot fly, but they swim well!

"""Q-5 Write a program to demonstrate encapsulation by creating a class BankAccount with private attributes
balance and methods to deposit, withdraw, and check balance.
"""

class BankAccount:
    def __init__(self, initial_balance=0):
        # Private attribute
        self.__balance = initial_balance

    # Method to deposit money
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print(f"Deposited: ${amount}")
        else:
            print("Deposit amount must be positive.")

    # Method to withdraw money
    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            print(f"Withdrew: ${amount}")
        else:
            print("Insufficient funds or invalid amount.")

    # Method to check balance
    def get_balance(self):
        return self.__balance

# Testing the class
if __name__ == "__main__":
    account = BankAccount(100)  # Starting with $100
    account.deposit(50)
    account.withdraw(30)
    print(f"Current Balance: ${account.get_balance()}")

    # Trying to access private attribute directly (will fail)
    try:
        print(account.__balance)
    except AttributeError as e:
        print(f"Error: {e}")

"""Q-6 Demonstrate runtime polymorphism using a method play() in a base class Instrument. Derive classes Guitar
and Piano that implement their own version of play().
"""

# Base class
class Instrument:
    def play(self):
        print("Instrument is being played...")

# Derived class: Guitar
class Guitar(Instrument):
    def play(self):
        print("Strumming the guitar strings!")

# Derived class: Piano
class Piano(Instrument):
    def play(self):
        print("Playing the piano keys!")

# Function to demonstrate runtime polymorphism
def start_playing(instrument):
    instrument.play()  # Calls the overridden method based on the object type

# Testing the classes
if __name__ == "__main__":
    instrument1 = Guitar()
    instrument2 = Piano()

    start_playing(instrument1)  # Output: Strumming the guitar strings!
    start_playing(instrument2)  # Output: Playing the piano keys!

"""Q-7  Create a class MathOperations with a class method add_numbers() to add two numbers and a static
method subtract_numbers() to subtract two numbers.
"""

class MathOperations:
    # Class method to add two numbers
    @classmethod
    def add_numbers(cls, a, b):
        return a + b

    # Static method to subtract two numbers
    @staticmethod
    def subtract_numbers(a, b):
        return a - b

# Testing the methods
if __name__ == "__main__":
    sum_result = MathOperations.add_numbers(10, 5)
    diff_result = MathOperations.subtract_numbers(10, 5)

    print(f"Sum: {sum_result}")
    print(f"Difference: {diff_result}")

"""Q-8  Implement a class Person with a class method to count the total number of persons created."""

class Person:
    # Class variable to store count of instances
    __count = 0

    def __init__(self, name):
        self.name = name
        Person.__count += 1

    # Class method to get total number of persons created
    @classmethod
    def total_persons(cls):
        return cls.__count

# Testing the class
if __name__ == "__main__":
    p1 = Person("Alice")
    p2 = Person("Bob")
    p3 = Person("Charlie")

    print(f"Total Persons Created: {Person.total_persons()}")

"""Q-9 Write a class Fraction with attributes numerator and denominator. Override the str method to display the
fraction as "numerator/denominator".
"""

class Fraction:
    def __init__(self, numerator, denominator):
        self.numerator = numerator
        if denominator == 0:
            raise ValueError("Denominator cannot be zero.")
        self.denominator = denominator

    # Override __str__ method to return "numerator/denominator"
    def __str__(self):
        return f"{self.numerator}/{self.denominator}"

# Testing the class
if __name__ == "__main__":
    f1 = Fraction(3, 4)
    f2 = Fraction(7, 1)

    print(f"Fraction 1: {f1}")  # Output: 3/4
    print(f"Fraction 2: {f2}")  # Output: 7/1

"""Q-10 . Demonstrate operator overloading by creating a class Vector and overriding the add method to add two
vectors.
"""

class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    # Overload the + operator
    def __add__(self, other):
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        return NotImplemented

    # Override __str__ for nice output
    def __str__(self):
        return f"Vector({self.x}, {self.y})"

# Testing the class
if __name__ == "__main__":
    v1 = Vector(2, 3)
    v2 = Vector(4, 1)
    v3 = v1 + v2  # Uses the __add__ method

    print(f"Vector 1: {v1}")
    print(f"Vector 2: {v2}")
    print(f"Sum: {v3}")  # Output: Vector(6, 4)

"""Q-11  Create a class Person with attributes name and age. Add a method greet() that prints "Hello, my name is
{name} and I am {age} years old."
"""

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        print(f"Hello, my name is {self.name} and I am {self.age} years old.")

# Testing the class
if __name__ == "__main__":
    p1 = Person("Alice", 30)
    p2 = Person("Bob", 25)

    p1.greet()  # Output: Hello, my name is Alice and I am 30 years old.
    p2.greet()  # Output: Hello, my name is Bob and I am 25 years old.

"""Q-12 Implement a class Student with attributes name and grades. Create a method average_grade() to compute
the average of the grades.
"""

class Student:
    def __init__(self, name, grades):
        self.name = name
        self.grades = grades  # Expecting a list of numbers

    def average_grade(self):
        if not self.grades:
            return 0  # Avoid division by zero
        return sum(self.grades) / len(self.grades)

# Testing the class
if __name__ == "__main__":
    student1 = Student("Alice", [85, 90, 78])
    student2 = Student("Bob", [72, 88, 95, 100])

    print(f"{student1.name}'s Average Grade: {student1.average_grade():.2f}")
    print(f"{student2.name}'s Average Grade: {student2.average_grade():.2f}")

"""Q-13 Create a class Rectangle with methods set_dimensions() to set the dimensions and area() to calculate the
area.
"""

class Rectangle:
    def __init__(self):
        self.width = 0
        self.height = 0

    def set_dimensions(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

# Testing the class
if __name__ == "__main__":
    rect = Rectangle()
    rect.set_dimensions(5, 10)
    print(f"Area of Rectangle: {rect.area()}")

"""Q-14 Create a class Employee with a method calculate_salary() that computes the salary based on hours worked
and hourly rate. Create a derived class Manager that adds a bonus to the salary.
"""

# Base class
class Employee:
    def __init__(self, name, hours_worked, hourly_rate):
        self.name = name
        self.hours_worked = hours_worked
        self.hourly_rate = hourly_rate

    def calculate_salary(self):
        return self.hours_worked * self.hourly_rate

# Derived class
class Manager(Employee):
    def __init__(self, name, hours_worked, hourly_rate, bonus):
        super().__init__(name, hours_worked, hourly_rate)
        self.bonus = bonus

    def calculate_salary(self):
        base_salary = super().calculate_salary()
        return base_salary + self.bonus

# Testing the classes
if __name__ == "__main__":
    emp = Employee("Alice", 40, 20)
    mgr = Manager("Bob", 40, 20, 500)

    print(f"{emp.name}'s Salary: ${emp.calculate_salary()}")
    print(f"{mgr.name}'s Salary (with bonus): ${mgr.calculate_salary()}")

"""Q-15 . Create a class Product with attributes name, price, and quantity. Implement a method total_price() that
calculates the total price of the product.
"""

class Product:
    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price
        self.quantity = quantity

    def total_price(self):
        return self.price * self.quantity

# Testing the class
if __name__ == "__main__":
    product = Product("Laptop", 999.99, 3)
    print(f"Total price of {product.name}: ${product.total_price():.2f}")

"""Q-16 Create a class Animal with an abstract method sound(). Create two derived classes Cow and Sheep that
implement the sound() method.
"""

from abc import ABC, abstractmethod

# Abstract base class
class Animal(ABC):
    @abstractmethod
    def sound(self):
        pass

# Derived class: Cow
class Cow(Animal):
    def sound(self):
        return "Moo"

# Derived class: Sheep
class Sheep(Animal):
    def sound(self):
        return "Baa"

# Testing the classes
if __name__ == "__main__":
    cow = Cow()
    sheep = Sheep()

    print(f"The cow says: {cow.sound()}")
    print(f"The sheep says: {sheep.sound()}")

"""Q- Create a class Book with attributes title, author, and year_published. Add a method get_book_info() that
returns a formatted string with the book's details.
"""

class Book:
    def __init__(self, title, author, year_published):
        self.title = title
        self.author = author
        self.year_published = year_published

    def get_book_info(self):
        return f"\"{self.title}\" by {self.author} (Published in {self.year_published})"

# Testing the class
if __name__ == "__main__":
    book1 = Book("1984", "George Orwell", 1949)
    book2 = Book("To Kill a Mockingbird", "Harper Lee", 1960)

    print(book1.get_book_info())
    print(book2.get_book_info())

"""Q-18 Create a class House with attributes address and price. Create a derived class Mansion that adds an
attribute number_of_rooms.
"""

# Base class
class House:
    def __init__(self, address, price):
        self.address = address
        self.price = price

    def display_info(self):
        return f"Address: {self.address}, Price: ${self.price}"

# Derived class
class Mansion(House):
    def __init__(self, address, price, number_of_rooms):
        super().__init__(address, price)
        self.number_of_rooms = number_of_rooms

    def display_info(self):
        base_info = super().display_info()
        return f"{base_info}, Rooms: {self.number_of_rooms}"

# Testing the classes
if __name__ == "__main__":
    house = House("123 Main St", 250000)
    mansion = Mansion("456 Luxury Lane", 1500000, 12)

    print(house.display_info())    # Output: Address: 123 Main St, Price: $250000
    print(mansion.display_info())  # Output: Address: 456 Luxury Lane, Price: $1500000, Rooms: 12